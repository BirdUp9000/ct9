<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ct9: /home/runner/work/ct9/ct9/include/ct9/Trie.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ct9
   </div>
   <div id="projectbrief">CT9 is a project that implements a prefix tree (also known as a trie) data structure to provide text autocomplete functionality.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_2home_2runner_2work_2ct9_2ct9_2include_2ct9_2Trie_8h-example.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">/home/runner/work/ct9/ct9/include/ct9/Trie.h</div></div>
</div><!--header-->
<div class="contents">
<p>Recursively clears all child nodes of this node.</p>
<p>Recursively clears all child nodes of this node.This method deletes all child nodes of the current node and clears the children map. It effectively resets the subtree rooted at this node.</p>
<dl class="section note"><dt>Note</dt><dd>This does not delete the current node itself, only its children. The node remains valid for further insertions or operations.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Ensure that no other references to the deleted child nodes exist, as this will lead to dangling pointers.</dd></dl>
<p>Node* root = new Node(); root-&gt;insert("apple", 0, root); root-&gt;insert("banana", 0, root); root-&gt;clear(); // The subtree is now empty, but root is still valid.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &lt;limits.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;queue&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stack&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="keyword">class </span><a id="_a0" name="_a0"></a><a class="code hl_class" href="classTrie.html">Trie</a> final {</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span>Node final {</div>
<div class="line">    Node() = <span class="keywordflow">default</span>;</div>
<div class="line">    ~Node() {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; child : children) {</div>
<div class="line">        <span class="keyword">delete</span> child.second;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> clearNode() {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; child : children) {</div>
<div class="line">        <span class="keyword">delete</span> child.second;</div>
<div class="line">      }</div>
<div class="line">      children.clear();</div>
<div class="line">    }</div>
<div class="line">    [[nodiscard]] std::queue&lt;std::string&gt; <a id="a1" name="a1"></a><a class="code hl_function" href="structTrie_1_1Node.html#a7b355369a59c8d69901736bfdd88b007">autocompleteNode</a>(<span class="keyword">const</span> std::string&amp; prefix, <span class="keywordtype">size_t</span> count) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a id="a2" name="a2"></a><a class="code hl_function" href="structTrie_1_1Node.html#a196db9af06d50509138b7c67c5aa7082">insert</a>(<span class="keyword">const</span> std::string&amp; text, <span class="keywordtype">size_t</span> index, Node* root);</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] std::queue&lt;std::string&gt; find(<span class="keywordtype">char</span> character) <span class="keyword">const</span>;</div>
<div class="line">    [[nodiscard]] std::string find() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    std::map&lt;char, Node*&gt; children;</div>
<div class="line">    <span class="keywordtype">bool</span> end_of_word = <span class="keyword">false</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  Node* root = <span class="keyword">new</span> Node();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">const</span> Node* getRoot()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> root; }</div>
<div class="line">  Node* getRoot() { <span class="keywordflow">return</span> root; }</div>
<div class="line">  <span class="keywordtype">void</span> setRoot(Node* root) { this-&gt;root = root; }</div>
<div class="line">  <a class="code hl_class" href="classTrie.html">Trie</a>() = <span class="keywordflow">default</span>;</div>
<div class="line">  <a class="code hl_class" href="classTrie.html">~Trie</a>() { <span class="keyword">delete</span> root; }</div>
<div class="line">  <a class="code hl_class" href="classTrie.html">Trie</a>(<span class="keyword">const</span> <a class="code hl_class" href="classTrie.html">Trie</a>&amp; trie);</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code hl_class" href="classTrie.html">Trie</a>(<span class="keyword">const</span> std::string&amp; str);</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code hl_class" href="classTrie.html">Trie</a>(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; vec_str);</div>
<div class="line">  <a class="code hl_class" href="classTrie.html">Trie</a>(<a class="code hl_class" href="classTrie.html">Trie</a>&amp;&amp; trie) <span class="keyword">noexcept</span>;</div>
<div class="line">  <a class="code hl_class" href="classTrie.html">Trie</a> operator+(<span class="keyword">const</span> <a class="code hl_class" href="classTrie.html">Trie</a>&amp; trie) <span class="keyword">const</span>;</div>
<div class="line">  <a class="code hl_class" href="classTrie.html">Trie</a> operator-(<span class="keyword">const</span> <a class="code hl_class" href="classTrie.html">Trie</a>&amp; trie) <span class="keyword">const</span>;</div>
<div class="line">  <a class="code hl_class" href="classTrie.html">Trie</a>&amp; operator=(<span class="keyword">const</span> <a class="code hl_class" href="classTrie.html">Trie</a>&amp; trie);</div>
<div class="line">  <a class="code hl_class" href="classTrie.html">Trie</a>&amp; operator=(<a class="code hl_class" href="classTrie.html">Trie</a>&amp;&amp; trie) <span class="keyword">noexcept</span>;  </div>
<div class="line">  [[nodiscard]] <span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> <a class="code hl_class" href="classTrie.html">Trie</a>&amp; trie);</div>
<div class="line">  [[nodiscard]] <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code hl_class" href="classTrie.html">Trie</a>&amp; trie);</div>
<div class="line">  [[nodiscard]] <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> <a class="code hl_class" href="classTrie.html">Trie</a>&amp; trie);</div>
<div class="line">  [[nodiscard]] <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> <a class="code hl_class" href="classTrie.html">Trie</a>&amp; trie);</div>
<div class="line">  [[nodiscard]] <span class="keywordtype">bool</span> operator&gt;=(<span class="keyword">const</span> <a class="code hl_class" href="classTrie.html">Trie</a>&amp; trie);</div>
<div class="line">  [[nodiscard]] <span class="keywordtype">bool</span> operator&lt;=(<span class="keyword">const</span> <a class="code hl_class" href="classTrie.html">Trie</a>&amp; trie);</div>
<div class="line">  <span class="keywordtype">void</span> del(<span class="keyword">const</span> std::string&amp; text);</div>
<div class="line">  std::string DEBUG(<span class="keyword">const</span> Node* node, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> level, <span class="keywordtype">int</span> parent_x, <span class="keywordtype">int</span> parent_y, <span class="keywordtype">char</span> letter) <span class="keyword">const</span>;</div>
<div class="line">  [[nodiscard]] std::queue&lt;std::string&gt; <a id="a3" name="a3"></a><a class="code hl_function" href="classTrie.html#a618ef49a48291bcf6184710e38398a4d">autocomplete</a>(<span class="keyword">const</span> std::string&amp; prefix, <span class="keywordtype">size_t</span> count = INT_MAX) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> <a id="a4" name="a4"></a><a class="code hl_function" href="classTrie.html#a82ded465e0c692fe9c783d471ed4f682">insert</a>(<span class="keyword">const</span> std::string&amp; text);</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <a id="a5" name="a5"></a><a class="code hl_function" href="classTrie.html#ae9c02d045830f0d6a0e56e78f30f3168">copyNodes</a>(Node* dstRoot, <span class="keyword">const</span> Node* srcRoot) {</div>
<div class="line">    dstRoot-&gt;clearNode();</div>
<div class="line">    std::queue&lt;const Node*&gt; srcQueue;</div>
<div class="line">    std::queue&lt;Node*&gt; dstQueue;</div>
<div class="line"> </div>
<div class="line">    srcQueue.push(srcRoot);</div>
<div class="line">    dstQueue.push(dstRoot);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (!srcQueue.empty()) {</div>
<div class="line">      <span class="keyword">auto</span> currentSrcNode = srcQueue.front();</div>
<div class="line">      srcQueue.pop();</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">auto</span> currentDstNode = dstQueue.front();</div>
<div class="line">      dstQueue.pop();</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; child : currentSrcNode-&gt;children) {</div>
<div class="line">        srcQueue.push(child.second);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">char</span> childChar = child.first;</div>
<div class="line">        Node* newDstNode = <span class="keyword">new</span> Node;</div>
<div class="line">        newDstNode-&gt;end_of_word = child.second-&gt;end_of_word;</div>
<div class="line"> </div>
<div class="line">        currentDstNode-&gt;children[childChar] = newDstNode;</div>
<div class="line">        dstQueue.push(newDstNode);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">Trie::Trie(<span class="keyword">const</span> <a class="code hl_class" href="classTrie.html">Trie</a>&amp; trie) {</div>
<div class="line">  <span class="keyword">const</span> Node* new_root = trie.<a id="a6" name="a6"></a>getRoot();</div>
<div class="line">  <a class="code hl_function" href="classTrie.html#ae9c02d045830f0d6a0e56e78f30f3168">Trie::copyNodes</a>(root, new_root);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Trie::Trie(<span class="keyword">const</span> std::string&amp; str) {</div>
<div class="line">  this-&gt;<a class="code hl_function" href="classTrie.html#a82ded465e0c692fe9c783d471ed4f682">insert</a>(str);</div>
<div class="line">}</div>
<div class="line">Trie::Trie(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; vec_str) {</div>
<div class="line">  <span class="keywordflow">for</span> (std::string word : vec_str) {</div>
<div class="line">    this-&gt;<a class="code hl_function" href="classTrie.html#a82ded465e0c692fe9c783d471ed4f682">insert</a>(word);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">Trie::Trie(<a class="code hl_class" href="classTrie.html">Trie</a>&amp;&amp; trie) <span class="keyword">noexcept</span> {</div>
<div class="line">  this-&gt;root = trie.getRoot();  </div>
<div class="line">  trie.<a id="a7" name="a7"></a>setRoot(<span class="keyword">nullptr</span>);       </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classTrie.html">Trie</a>&amp; Trie::operator=(<a class="code hl_class" href="classTrie.html">Trie</a>&amp;&amp; trie) <span class="keyword">noexcept</span> {</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;trie) {</div>
<div class="line">    <span class="keyword">delete</span> root;</div>
<div class="line">    root = trie.getRoot();</div>
<div class="line">    trie.setRoot(<span class="keyword">nullptr</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">[[nodiscard]] std::queue&lt;std::string&gt; <a class="code hl_function" href="classTrie.html#a618ef49a48291bcf6184710e38398a4d">Trie::autocomplete</a>(<span class="keyword">const</span> std::string&amp; prefix, <span class="keywordtype">size_t</span> count)<span class="keyword"> const </span>{</div>
<div class="line">  Node* tmp_node = root;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; character : prefix) {</div>
<div class="line">    <span class="keywordflow">if</span> (!tmp_node-&gt;children.contains(character)) {</div>
<div class="line">      <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line">    tmp_node = tmp_node-&gt;children[character];</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> tmp_node-&gt;autocompleteNode(prefix, count);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">[[nodiscard]] std::queue&lt;std::string&gt; <a class="code hl_function" href="structTrie_1_1Node.html#a7b355369a59c8d69901736bfdd88b007">Trie::Node::autocompleteNode</a>(<span class="keyword">const</span> std::string&amp; prefix, <span class="keywordtype">size_t</span> count)<span class="keyword"> const </span>{</div>
<div class="line">  std::stack&lt;std::pair&lt;const Node*, std::string&gt;&gt; stack;</div>
<div class="line">  std::queue&lt;std::string&gt; results;</div>
<div class="line">  stack.push({<span class="keyword">this</span>, prefix});</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span> (!stack.empty() &amp;&amp; results.size() &lt; count) {</div>
<div class="line">    <span class="keyword">auto</span> [current_node, word] = stack.top();</div>
<div class="line">    stack.pop();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (current_node-&gt;end_of_word) {</div>
<div class="line">      results.push(word);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = current_node-&gt;children.rbegin(); it != current_node-&gt;children.rend(); ++it) {</div>
<div class="line">      stack.push({it-&gt;second, word + it-&gt;first});</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> results;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code hl_function" href="classTrie.html#a82ded465e0c692fe9c783d471ed4f682">Trie::insert</a>(<span class="keyword">const</span> std::string&amp; text) { root-&gt;<a class="code hl_function" href="structTrie_1_1Node.html#a196db9af06d50509138b7c67c5aa7082">insert</a>(text, 0, root); }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code hl_function" href="structTrie_1_1Node.html#a196db9af06d50509138b7c67c5aa7082">Trie::Node::insert</a>(<span class="keyword">const</span> std::string&amp; text, <span class="keyword">const</span> <span class="keywordtype">size_t</span> index, Node* root) {</div>
<div class="line">  <span class="keywordflow">if</span> (index == text.size()) {</div>
<div class="line">    end_of_word = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Mark as end of word if a non-alphabetic character is encountered</span></div>
<div class="line">  <span class="keywordflow">if</span> (isalpha(text[index]) == 0) {</div>
<div class="line">    end_of_word = <span class="keyword">true</span>;</div>
<div class="line">    root-&gt;insert(text, index + 1, root);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Create a new node if the current character is not found</span></div>
<div class="line">    <span class="keywordflow">if</span> (!children.contains(text[index])) {</div>
<div class="line">      children[text[index]] = <span class="keyword">new</span> Node();</div>
<div class="line">    }</div>
<div class="line">    children[text[index]]-&gt;insert(text, index + 1, root);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// TODO: constexpr set with supportable chars</span></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">inline std::string Trie::DEBUG(const Node* node, int x, int y, int level, int parent_x, int parent_y, const char letter)</span></div>
<div class="line"><span class="comment">const { if (!node) return &quot;&quot;;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  std::ostringstream svg;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  int box_width = 20;</span></div>
<div class="line"><span class="comment">  int box_height = 20;</span></div>
<div class="line"><span class="comment">  int vertical_spacing = 50;</span></div>
<div class="line"><span class="comment">  int horizontal_spacing = 10 * std::max(1, static_cast&lt;int&gt;(node-&gt;children.size()));</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  if (level &gt; 0) {</span></div>
<div class="line"><span class="comment">    svg &lt;&lt; &quot;&lt;line x1=\&quot;&quot; &lt;&lt; parent_x + box_width / 2 &lt;&lt; &quot;\&quot; y1=\&quot;&quot; &lt;&lt; parent_y + box_height</span></div>
<div class="line"><span class="comment">        &lt;&lt; &quot;\&quot; x2=\&quot;&quot; &lt;&lt; x + box_width / 2 &lt;&lt; &quot;\&quot; y2=\&quot;&quot; &lt;&lt; y</span></div>
<div class="line"><span class="comment">        &lt;&lt; &quot;\&quot; stroke=\&quot;black\&quot; stroke-width=\&quot;2\&quot; /&gt;\n&quot;;</span></div>
<div class="line"><span class="comment">  }</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  svg &lt;&lt; &quot;&lt;rect x=\&quot;&quot; &lt;&lt; x &lt;&lt; &quot;\&quot; y=\&quot;&quot; &lt;&lt; y &lt;&lt; &quot;\&quot; width=\&quot;&quot; &lt;&lt; box_width</span></div>
<div class="line"><span class="comment">      &lt;&lt; &quot;\&quot; height=\&quot;&quot; &lt;&lt; box_height &lt;&lt; &quot;\&quot; rx=\&quot;10\&quot; ry=\&quot;10\&quot; fill=\&quot;blue\&quot; /&gt;\n&quot;;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  svg &lt;&lt; &quot;&lt;text x=\&quot;&quot; &lt;&lt; (x + box_width / 2) &lt;&lt; &quot;\&quot; y=\&quot;&quot; &lt;&lt; (y + box_height / 2)</span></div>
<div class="line"><span class="comment">      &lt;&lt; &quot;\&quot; font-size=\&quot;20\&quot; fill=\&quot;white\&quot; text-anchor=\&quot;middle\&quot; dominant-baseline=\&quot;middle\&quot;&gt;&quot;</span></div>
<div class="line"><span class="comment">      &lt;&lt; letter &lt;&lt; &quot;&lt;/text&gt;\n&quot;;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  int num_children = node-&gt;children.size();</span></div>
<div class="line"><span class="comment">  int start_x = x - (num_children - 1) * horizontal_spacing / 2;</span></div>
<div class="line"><span class="comment">  int child_x = start_x;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  for (const auto&amp; [key, child] : node-&gt;children) {</span></div>
<div class="line"><span class="comment">    svg &lt;&lt; DEBUG(child.get(), child_x, y + vertical_spacing, level + 1, x, y, key);</span></div>
<div class="line"><span class="comment">    child_x += horizontal_spacing;</span></div>
<div class="line"><span class="comment">  }</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  return svg.str();</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="ttc" id="aclassTrie_html"><div class="ttname"><a href="classTrie.html">Trie</a></div><div class="ttdef"><b>Definition</b> Trie.h:14</div></div>
<div class="ttc" id="aclassTrie_html_a618ef49a48291bcf6184710e38398a4d"><div class="ttname"><a href="classTrie.html#a618ef49a48291bcf6184710e38398a4d">Trie::autocomplete</a></div><div class="ttdeci">std::queue&lt; std::string &gt; autocomplete(const std::string &amp;prefix, size_t count=INT_MAX) const</div><div class="ttdoc">Provides autocomplete suggestions based on the given prefix.</div><div class="ttdef"><b>Definition</b> Trie.h:172</div></div>
<div class="ttc" id="aclassTrie_html_a82ded465e0c692fe9c783d471ed4f682"><div class="ttname"><a href="classTrie.html#a82ded465e0c692fe9c783d471ed4f682">Trie::insert</a></div><div class="ttdeci">void insert(const std::string &amp;text)</div><div class="ttdoc">Inserts a word into the trie.</div><div class="ttdef"><b>Definition</b> Trie.h:225</div></div>
<div class="ttc" id="aclassTrie_html_ae9c02d045830f0d6a0e56e78f30f3168"><div class="ttname"><a href="classTrie.html#ae9c02d045830f0d6a0e56e78f30f3168">Trie::copyNodes</a></div><div class="ttdeci">static void copyNodes(Node *dstRoot, const Node *srcRoot)</div><div class="ttdoc">Copies all nodes from a source trie to a destination trie.</div><div class="ttdef"><b>Definition</b> Trie.h:101</div></div>
<div class="ttc" id="astructTrie_1_1Node_html_a196db9af06d50509138b7c67c5aa7082"><div class="ttname"><a href="structTrie_1_1Node.html#a196db9af06d50509138b7c67c5aa7082">Trie::Node::insert</a></div><div class="ttdeci">void insert(const std::string &amp;text, size_t index, Node *root)</div><div class="ttdoc">Recursively inserts characters of the string into the trie.</div><div class="ttdef"><b>Definition</b> Trie.h:237</div></div>
<div class="ttc" id="astructTrie_1_1Node_html_a7b355369a59c8d69901736bfdd88b007"><div class="ttname"><a href="structTrie_1_1Node.html#a7b355369a59c8d69901736bfdd88b007">Trie::Node::autocompleteNode</a></div><div class="ttdeci">std::queue&lt; std::string &gt; autocompleteNode(const std::string &amp;prefix, size_t count) const</div><div class="ttdoc">Helper function to gather autocomplete suggestions from a specific node.</div><div class="ttdef"><b>Definition</b> Trie.h:194</div></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
